Bridge.assembly("MazeGenerators",function($asm,globals){"use strict";Bridge.define("MazeGenerators.Directions",{statics:{fields:{CardinalDirs:null,CompassDirs:null},ctors:{init:function(){this.CardinalDirs=System.Array.init([new MazeGenerators.Utils.Vector2.$ctor1(1,0),new MazeGenerators.Utils.Vector2.$ctor1(0,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,0),new MazeGenerators.Utils.Vector2.$ctor1(0,1)],MazeGenerators.Utils.Vector2);this.CompassDirs=System.Array.init([new MazeGenerators.Utils.Vector2.$ctor1(1,0),new MazeGenerators.Utils.Vector2.$ctor1(1,-1),new MazeGenerators.Utils.Vector2.$ctor1(0,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,0),new MazeGenerators.Utils.Vector2.$ctor1(-1,1),new MazeGenerators.Utils.Vector2.$ctor1(0,1),new MazeGenerators.Utils.Vector2.$ctor1(1,1)],MazeGenerators.Utils.Vector2)}}}});Bridge.define("MazeGenerators.RoomMazeGenerator",{methods:{Generate:function(settings){var $t,result,regionId,i,y,x,pos;if(settings.Width%2==0||settings.Height%2==0)throw new System.Exception("The stage must be odd-sized.");for(result=($t=new MazeGenerators.RoomMazeGenerator.Result,$t.Junctions=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),$t.Rooms=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Rectangle).ctor),$t.Regions=System.Array.create(null,null,System.Nullable$1(System.Int32),settings.Width,settings.Height),$t),regionId=-1,i=0;i<settings.NumRoomTries;i=i+1|0)regionId=regionId+1|0,this.TryAddRooms(result,settings,regionId)||(regionId=regionId-1|0);for(y=1;y<settings.Height;y=y+2|0)for(x=1;x<settings.Width;x=x+2|0)(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),System.Nullable.hasValue(result.GetTile(pos.$clone())))||(regionId=regionId+1|0,this.GrowMaze(result,settings,pos.$clone(),regionId));return regionId=regionId+1|0,this.ConnectRegions(result,settings,regionId),this.RemoveDeadEnds(result,settings),result},GrowMaze:function(result,settings,start,regionId){var $t,cells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),lastDir,cell,unmadeCells,dir,dir1;for(result.SetTile(start.$clone(),regionId),cells.add(start.$clone()),lastDir=null;cells.Count>0;){cell=cells.getItem(cells.Count-1|0).$clone();unmadeCells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor);$t=Bridge.getEnumerator(settings.Directions);try{while($t.moveNext())dir=$t.Current.$clone(),this.CanCarve(result,cell.$clone(),dir.$clone())&&unmadeCells.add(dir.$clone())}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}unmadeCells.Count!==0?(dir1=new MazeGenerators.Utils.Vector2,dir1=lastDir!=null&&unmadeCells.contains(System.Nullable.getValue(lastDir).$clone())&&settings.Random.Next$1(100)>settings.WindingPercent?System.Nullable.getValue(lastDir).$clone():unmadeCells.getItem(settings.Random.Next$1(unmadeCells.Count)).$clone(),result.SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),dir1.$clone()),regionId),result.SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2)),regionId),cells.add(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2))),lastDir=dir1.$clone()):(cells.removeAt(cells.Count-1|0),lastDir=null)}},TryAddRooms:function(result,settings,regionId){var $t,size=Bridge.Int.mul(settings.Random.Next$1(2+settings.RoomExtraSize|0)+1|0,2)+1|0,rectangularity=Bridge.Int.mul(settings.Random.Next$1(1+(Bridge.Int.div(size,2)|0)|0),2),width=size,height=size,other,i1,j1;settings.Random.Next$1(100)<50?width=width+rectangularity|0:height=height+rectangularity|0;var x=Bridge.Int.mul(settings.Random.Next$1(Bridge.Int.div(System.Array.getLength(result.Regions,0)-width|0,2)|0),2)+1|0,y=Bridge.Int.mul(settings.Random.Next$1(Bridge.Int.div(System.Array.getLength(result.Regions,1)-height|0,2)|0),2)+1|0,room=new MazeGenerators.Utils.Rectangle.$ctor1(x,y,width,height),overlaps=!1;$t=Bridge.getEnumerator(result.Rooms);try{while($t.moveNext())if(other=$t.Current.$clone(),room.Intersects(other.$clone())){overlaps=!0;break}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}if(overlaps)return!1;for(result.Rooms.add(room.$clone()),i1=x;i1<(x+width|0);i1=i1+1|0)for(j1=y;j1<(y+height|0);j1=j1+1|0)result.SetTile(new MazeGenerators.Utils.Vector2.$ctor1(i1,j1),regionId);return!0},ConnectRegions:function(result,settings,connectorId){for(var y,pos,tmpRegions,dir,loc,region,i,connector,i1,source,$t,$t1,connectorRegions=new(System.Collections.Generic.Dictionary$2(MazeGenerators.Utils.Vector2,System.Collections.Generic.HashSet$1(System.Int32))),x=0;x<System.Array.getLength(result.Regions,0);x=x+1|0)for(y=0;y<System.Array.getLength(result.Regions,1);y=y+1|0)if(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),!System.Nullable.hasValue(result.GetTile(pos.$clone()))){tmpRegions=new(System.Collections.Generic.HashSet$1(System.Int32).ctor);$t=Bridge.getEnumerator(settings.Directions);try{while($t.moveNext())(dir=$t.Current.$clone(),loc=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone()),result.IsInRegion(loc.$clone()))&&(region=result.GetTile(loc.$clone()),region!=null&&tmpRegions.add(System.Nullable.getValue(region)))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}tmpRegions.Count<2||connectorRegions.set(pos,tmpRegions)}var connectors=System.Linq.Enumerable.from(connectorRegions.getKeys()).toList(MazeGenerators.Utils.Vector2),merged=System.Array.init(connectorId,0,System.Int32),openRegions=new(System.Collections.Generic.HashSet$1(System.Int32).ctor);for(i=0;i<connectorId;i=i+1|0)merged[System.Array.index(i,merged)]=i,openRegions.add(i);while(openRegions.Count>1){connector={v:connectors.getItem(settings.Random.Next$1(connectors.Count)).$clone()};result.SetTile(connector.v.$clone(),connectorId);result.Junctions.add(connector.v.$clone());var tmpRegions1=System.Linq.Enumerable.from(connectorRegions.get(connector.v)).select(function(region1){return merged[System.Array.index(region1,merged)]}).toList(System.Int32),dest=tmpRegions1.getItem(0),sources=System.Linq.Enumerable.from(tmpRegions1).skip(1).toList(System.Int32);for(i1=0;i1<connectorId;i1=i1+1|0)sources.contains(merged[System.Array.index(i1,merged)])&&(merged[System.Array.index(i1,merged)]=dest);$t1=Bridge.getEnumerator(sources);try{while($t1.moveNext())source=$t1.Current,openRegions.remove(source)}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}connectors.RemoveAll(function($me,connector){return function(pos1){if(MazeGenerators.Utils.Vector2.op_Subtraction(connector.v.$clone(),pos1.$clone()).LengthSquared()<4)return!0;var tmpRegions2=System.Linq.Enumerable.from(System.Linq.Enumerable.from(connectorRegions.get(pos1)).select(function(region1){return merged[System.Array.index(region1,merged)]})).toLookup($asm.$.MazeGenerators.RoomMazeGenerator.f1,$asm.$.MazeGenerators.RoomMazeGenerator.f1);return tmpRegions2.count()>1?!1:(settings.Random.Next$1(100)<settings.ExtraConnectorChance&&(result.SetTile(pos1.$clone(),connectorId),result.Junctions.add(pos1.$clone())),!0)}}(this,connector))}},RemoveDeadEnds:function(result,settings){for(var $t,done=!1,x,y,pos,exits,dir;!done;)for(done=!0,x=0;x<System.Array.getLength(result.Regions,0);x=x+1|0)for(y=0;y<System.Array.getLength(result.Regions,1);y=y+1|0)if(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),System.Nullable.hasValue(result.GetTile(pos.$clone()))){exits=0;$t=Bridge.getEnumerator(settings.Directions);try{while($t.moveNext())(dir=$t.Current.$clone(),result.IsInRegion(MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone())))&&System.Nullable.hasValue(result.GetTile(MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone())))&&(exits=exits+1|0)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}exits===1&&(done=!1,result.RemoveTile(pos.$clone()))}},CanCarve:function(result,pos,direction){var block=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),3)),end;return result.IsInRegion(block.$clone())?(end=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),2)),!System.Nullable.hasValue(result.GetTile(end.$clone()))):!1}}});Bridge.ns("MazeGenerators.RoomMazeGenerator",$asm.$);Bridge.apply($asm.$.MazeGenerators.RoomMazeGenerator,{f1:function(a){return a}});Bridge.define("MazeGenerators.RoomMazeGenerator.Result",{$kind:"nested class",fields:{Junctions:null,Rooms:null,Regions:null},methods:{GetTile:function(pos){return this.Regions.get([pos.X,pos.Y])},SetTile:function(pos,regionId){this.Regions.set([pos.X,pos.Y],regionId)},RemoveTile:function(pos){this.Regions.set([pos.X,pos.Y],null)},IsInRegion:function(loc){return loc.X>=0&&loc.Y>=0&&loc.X<System.Array.getLength(this.Regions,0)&&loc.Y<System.Array.getLength(this.Regions,1)}}});Bridge.define("MazeGenerators.RoomMazeGenerator.Settings",{$kind:"nested class",fields:{Width:0,Height:0,Random:null,Directions:null,NumRoomTries:0,ExtraConnectorChance:0,RoomExtraSize:0,WindingPercent:0},ctors:{init:function(){this.Random=new System.Random.ctor;this.Directions=MazeGenerators.Directions.CardinalDirs;this.NumRoomTries=100;this.ExtraConnectorChance=20;this.RoomExtraSize=0;this.WindingPercent=0},ctor:function(width,height){this.$initialize();this.Width=width;this.Height=height}}});Bridge.define("MazeGenerators.TreeMazeGenerator",{methods:{Generate:function(settings){var $t,result;if(settings.Width%2==0||settings.Height%2==0)throw new System.Exception("The stage must be odd-sized.");return result=($t=new MazeGenerators.TreeMazeGenerator.Result,$t.Regions=System.Array.create(null,null,System.Nullable$1(System.Int32),settings.Width,settings.Height),$t),this.GrowMaze(result,settings,new MazeGenerators.Utils.Vector2.$ctor1(1,1),1),result},GrowMaze:function(result,settings,start,regionId){var $t,cells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),lastDir,cell,unmadeCells,dir,dir1;for(result.SetTile(start.$clone(),regionId),cells.add(start.$clone()),lastDir=null;cells.Count>0;){cell=cells.getItem(cells.Count-1|0).$clone();unmadeCells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor);$t=Bridge.getEnumerator(settings.Directions);try{while($t.moveNext())dir=$t.Current.$clone(),this.CanCarve(result,cell.$clone(),dir.$clone())&&unmadeCells.add(dir.$clone())}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}unmadeCells.Count!==0?(dir1=new MazeGenerators.Utils.Vector2,dir1=lastDir!=null&&unmadeCells.contains(System.Nullable.getValue(lastDir).$clone())&&settings.Random.Next$1(100)>settings.WindingPercent?System.Nullable.getValue(lastDir).$clone():unmadeCells.getItem(settings.Random.Next$1(unmadeCells.Count)).$clone(),result.SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),dir1.$clone()),regionId),result.SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2)),regionId),cells.add(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2))),lastDir=dir1.$clone()):(cells.removeAt(cells.Count-1|0),lastDir=null)}},CanCarve:function(result,pos,direction){var block=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),3)),end;return result.IsInRegion(block.$clone())?(end=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),2)),!System.Nullable.hasValue(result.GetTile(end.$clone()))):!1}}});Bridge.define("MazeGenerators.TreeMazeGenerator.Result",{$kind:"nested class",fields:{Regions:null},methods:{GetTile:function(pos){return this.Regions.get([pos.X,pos.Y])},SetTile:function(pos,regionId){this.Regions.set([pos.X,pos.Y],regionId)},RemoveTile:function(pos){this.Regions.set([pos.X,pos.Y],null)},IsInRegion:function(loc){return loc.X>=0&&loc.Y>=0&&loc.X<System.Array.getLength(this.Regions,0)&&loc.Y<System.Array.getLength(this.Regions,1)}}});Bridge.define("MazeGenerators.TreeMazeGenerator.Settings",{$kind:"nested class",fields:{Width:0,Height:0,Random:null,Directions:null,WindingPercent:0},ctors:{init:function(){this.Random=new System.Random.ctor;this.Directions=MazeGenerators.Directions.CardinalDirs;this.WindingPercent=100},ctor:function(width,height){this.$initialize();this.Width=width;this.Height=height}}});Bridge.define("MazeGenerators.Utils.Rectangle",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new MazeGenerators.Utils.Rectangle}}},fields:{X:0,Y:0,Width:0,Height:0},ctors:{$ctor1:function(x,y,width,height){this.$initialize();this.X=x;this.Y=y;this.Width=width;this.Height=height},ctor:function(){this.$initialize()}},methods:{Intersects:function(value){return value.X<(this.X+this.Width|0)&&this.X<(value.X+value.Width|0)&&value.Y<(this.Y+this.Height|0)&&this.Y<(value.Y+value.Height|0)},getHashCode:function(){return Bridge.addHash([3771388952,this.X,this.Y,this.Width,this.Height])},equals:function(o){return Bridge.is(o,MazeGenerators.Utils.Rectangle)?Bridge.equals(this.X,o.X)&&Bridge.equals(this.Y,o.Y)&&Bridge.equals(this.Width,o.Width)&&Bridge.equals(this.Height,o.Height):!1},$clone:function(to){var s=to||new MazeGenerators.Utils.Rectangle;return s.X=this.X,s.Y=this.Y,s.Width=this.Width,s.Height=this.Height,s}}});Bridge.define("MazeGenerators.Utils.Vector2",{$kind:"struct",statics:{methods:{op_Addition:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(a.X+b.X|0,a.Y+b.Y|0)},op_Subtraction:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(a.X-b.X|0,a.Y-b.Y|0)},op_Multiply:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(Bridge.Int.mul(a.X,b),Bridge.Int.mul(a.Y,b))},getDefaultValue:function(){return new MazeGenerators.Utils.Vector2}}},fields:{X:0,Y:0},ctors:{$ctor1:function(x,y){this.$initialize();this.X=x;this.Y=y},ctor:function(){this.$initialize()}},methods:{LengthSquared:function(){return Bridge.Int.mul(this.X,this.X)+Bridge.Int.mul(this.Y,this.Y)|0},getHashCode:function(){return Bridge.addHash([1955977157,this.X,this.Y])},equals:function(o){return Bridge.is(o,MazeGenerators.Utils.Vector2)?Bridge.equals(this.X,o.X)&&Bridge.equals(this.Y,o.Y):!1},$clone:function(to){var s=to||new MazeGenerators.Utils.Vector2;return s.X=this.X,s.Y=this.Y,s}}})});