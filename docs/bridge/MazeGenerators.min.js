Bridge.assembly("MazeGenerators",function($asm,globals){"use strict";Bridge.define("MazeGenerators.RoomMazeGenerator",{methods:{Generate:function(settings){var $t,result,regionId,i,y,x,pos;if(settings.Width%2==0||settings.Height%2==0)throw new System.Exception("The stage must be odd-sized.");for(result=($t=new MazeGenerators.RoomMazeGenerator.Result,$t.Junctions=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),$t.Rooms=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Rectangle).ctor),$t.Regions=System.Array.create(null,null,System.Nullable$1(System.Int32),settings.Width,settings.Height),$t),regionId=-1,i=0;i<settings.NumRoomTries;i=i+1|0)regionId=regionId+1|0,this.TryAddRooms(result,settings,regionId)||(regionId=regionId-1|0);for(y=1;y<settings.Height;y=y+2|0)for(x=1;x<settings.Width;x=x+2|0)(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),System.Nullable.hasValue(result.GetTile(pos.$clone())))||(regionId=regionId+1|0,MazeGenerators.Utils.RegionConnector.TreeMazeBuilderAlgorythm.GrowMaze(result,settings,pos.$clone(),regionId));return regionId=regionId+1|0,this.ConnectRegions(result,settings,regionId),MazeGenerators.Utils.RegionConnector.RegionConnectorAlgorythm.ConnectRegions(result,settings,regionId),MazeGenerators.Utils.DeadendRemover.DeadEndRemoverAlgorythm.RemoveDeadEnds(result,settings),result},TryAddRooms:function(result,settings,regionId){var $t,size=Bridge.Int.mul(settings.Random.Next$1(settings.RoomSize)+1|0,2)+1|0,rectangularity=Bridge.Int.mul(settings.Random.Next$1(1+(Bridge.Int.div(size,2)|0)|0),2),width=size,height=size,other,i1,j1;settings.Random.Next$1(100)<50?width=width+rectangularity|0:height=height+rectangularity|0;var x=Bridge.Int.mul(settings.Random.Next$1(Bridge.Int.div(System.Array.getLength(result.Regions,0)-width|0,2)|0),2)+1|0,y=Bridge.Int.mul(settings.Random.Next$1(Bridge.Int.div(System.Array.getLength(result.Regions,1)-height|0,2)|0),2)+1|0,room=new MazeGenerators.Utils.Rectangle.$ctor1(x,y,width,height),overlaps=!1;if(settings.PreventOverlappedRooms){$t=Bridge.getEnumerator(result.Rooms);try{while($t.moveNext())if(other=$t.Current.$clone(),room.Intersects(other.$clone())){overlaps=!0;break}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}if(overlaps)return!1;for(result.Rooms.add(room.$clone()),i1=x;i1<(x+width|0);i1=i1+1|0)for(j1=y;j1<(y+height|0);j1=j1+1|0)result.SetTile(new MazeGenerators.Utils.Vector2.$ctor1(i1,j1),regionId);return!0},ConnectRegions:function(result,settings,connectorId){for(var y,pos,tmpRegions,dir,loc,region,i,connector,i1,source,$t,$t1,connectorRegions=new(System.Collections.Generic.Dictionary$2(MazeGenerators.Utils.Vector2,System.Collections.Generic.HashSet$1(System.Int32))),x=0;x<System.Array.getLength(result.Regions,0);x=x+1|0)for(y=0;y<System.Array.getLength(result.Regions,1);y=y+1|0)if(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),!System.Nullable.hasValue(result.GetTile(pos.$clone()))){tmpRegions=new(System.Collections.Generic.HashSet$1(System.Int32).ctor);$t=Bridge.getEnumerator(settings.Directions);try{while($t.moveNext())(dir=$t.Current.$clone(),loc=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone()),result.IsInRegion(loc.$clone()))&&(region=result.GetTile(loc.$clone()),region!=null&&tmpRegions.add(System.Nullable.getValue(region)))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}tmpRegions.Count<2||connectorRegions.set(pos,tmpRegions)}var connectors=System.Linq.Enumerable.from(connectorRegions.getKeys()).toList(MazeGenerators.Utils.Vector2),merged=System.Array.init(connectorId,0,System.Int32),openRegions=new(System.Collections.Generic.HashSet$1(System.Int32).ctor);for(i=0;i<connectorId;i=i+1|0)merged[System.Array.index(i,merged)]=i,openRegions.add(i);while(openRegions.Count>1){connector={v:connectors.getItem(settings.Random.Next$1(connectors.Count)).$clone()};result.SetTile(connector.v.$clone(),connectorId);result.Junctions.add(connector.v.$clone());var tmpRegions1=System.Linq.Enumerable.from(connectorRegions.get(connector.v)).select(function(region1){return merged[System.Array.index(region1,merged)]}).toList(System.Int32),dest=tmpRegions1.getItem(0),sources=System.Linq.Enumerable.from(tmpRegions1).skip(1).toList(System.Int32);for(i1=0;i1<connectorId;i1=i1+1|0)sources.contains(merged[System.Array.index(i1,merged)])&&(merged[System.Array.index(i1,merged)]=dest);$t1=Bridge.getEnumerator(sources);try{while($t1.moveNext())source=$t1.Current,openRegions.remove(source)}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}connectors.RemoveAll(function($me,connector){return function(pos1){if(MazeGenerators.Utils.Vector2.op_Subtraction(connector.v.$clone(),pos1.$clone()).LengthSquared()<4)return!0;var tmpRegions2=System.Linq.Enumerable.from(System.Linq.Enumerable.from(connectorRegions.get(pos1)).select(function(region1){return merged[System.Array.index(region1,merged)]})).toLookup($asm.$.MazeGenerators.RoomMazeGenerator.f1,$asm.$.MazeGenerators.RoomMazeGenerator.f1);return tmpRegions2.count()>1?!1:!0}}(this,connector))}}}});Bridge.ns("MazeGenerators.RoomMazeGenerator",$asm.$);Bridge.apply($asm.$.MazeGenerators.RoomMazeGenerator,{f1:function(a){return a}});Bridge.define("MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderResult",{$kind:"interface"});Bridge.define("MazeGenerators.Utils.RegionConnector.IRegionConnectorResult",{$kind:"interface"});Bridge.define("MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverResult",{$kind:"interface"});Bridge.define("MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderSettings",{$kind:"interface"});Bridge.define("MazeGenerators.Utils.RegionConnector.IRegionConnectorSettings",{$kind:"interface"});Bridge.define("MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverSettings",{$kind:"interface"});Bridge.define("MazeGenerators.TreeMazeGenerator",{methods:{Generate:function(settings){var $t,result;if(settings.Width%2==0||settings.Height%2==0)throw new System.Exception("The stage must be odd-sized.");return result=($t=new MazeGenerators.TreeMazeGenerator.Result,$t.Regions=System.Array.create(null,null,System.Nullable$1(System.Int32),settings.Width,settings.Height),$t.Junctions=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),$t),MazeGenerators.Utils.RegionConnector.TreeMazeBuilderAlgorythm.GrowMaze(result,settings,new MazeGenerators.Utils.Vector2.$ctor1(1,1),1),MazeGenerators.Utils.RegionConnector.RegionConnectorAlgorythm.ConnectRegions(result,settings,2),MazeGenerators.Utils.DeadendRemover.DeadEndRemoverAlgorythm.RemoveDeadEnds(result,settings),result}}});Bridge.define("MazeGenerators.Utils.DeadendRemover.DeadEndRemoverAlgorythm",{statics:{methods:{RemoveDeadEnds:function(result,settings){var $t,done,x,y,pos,exits,dir;if(settings.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$RemoveDeadEnds)for(done=!1;!done;)for(done=!0,x=0;x<settings.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Width;x=x+1|0)for(y=0;y<settings.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Height;y=y+1|0)if(pos=new MazeGenerators.Utils.Vector2.$ctor1(x,y),System.Nullable.hasValue(result.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$GetTile(pos.$clone()))){exits=0;$t=Bridge.getEnumerator(settings.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Directions);try{while($t.moveNext())(dir=$t.Current.$clone(),result.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$IsInRegion(MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone())))&&System.Nullable.hasValue(result.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$GetTile(MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone())))&&(exits=exits+1|0)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}exits===1&&(done=!1,result.MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$RemoveTile(pos.$clone()))}}}}});Bridge.define("MazeGenerators.Utils.Directions",{statics:{fields:{CardinalDirs:null,CompassDirs:null},ctors:{init:function(){this.CardinalDirs=System.Array.init([new MazeGenerators.Utils.Vector2.$ctor1(1,0),new MazeGenerators.Utils.Vector2.$ctor1(0,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,0),new MazeGenerators.Utils.Vector2.$ctor1(0,1)],MazeGenerators.Utils.Vector2);this.CompassDirs=System.Array.init([new MazeGenerators.Utils.Vector2.$ctor1(1,0),new MazeGenerators.Utils.Vector2.$ctor1(1,-1),new MazeGenerators.Utils.Vector2.$ctor1(0,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,-1),new MazeGenerators.Utils.Vector2.$ctor1(-1,0),new MazeGenerators.Utils.Vector2.$ctor1(-1,1),new MazeGenerators.Utils.Vector2.$ctor1(0,1),new MazeGenerators.Utils.Vector2.$ctor1(1,1)],MazeGenerators.Utils.Vector2)}}}});Bridge.define("MazeGenerators.Utils.Rectangle",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new MazeGenerators.Utils.Rectangle}}},fields:{X:0,Y:0,Width:0,Height:0},ctors:{$ctor1:function(x,y,width,height){this.$initialize();this.X=x;this.Y=y;this.Width=width;this.Height=height},ctor:function(){this.$initialize()}},methods:{Intersects:function(value){return value.X<(this.X+this.Width|0)&&this.X<(value.X+value.Width|0)&&value.Y<(this.Y+this.Height|0)&&this.Y<(value.Y+value.Height|0)},getHashCode:function(){return Bridge.addHash([3771388952,this.X,this.Y,this.Width,this.Height])},equals:function(o){return Bridge.is(o,MazeGenerators.Utils.Rectangle)?Bridge.equals(this.X,o.X)&&Bridge.equals(this.Y,o.Y)&&Bridge.equals(this.Width,o.Width)&&Bridge.equals(this.Height,o.Height):!1},$clone:function(to){var s=to||new MazeGenerators.Utils.Rectangle;return s.X=this.X,s.Y=this.Y,s.Width=this.Width,s.Height=this.Height,s}}});Bridge.define("MazeGenerators.Utils.RegionConnector.RegionConnectorAlgorythm",{statics:{methods:{ConnectRegions:function(result,settings,connectorId){for(var pos,found,region1,region2,$t,i=0;i<settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$AdditionalPassages;i=i+1|0){if(pos=new MazeGenerators.Utils.Vector2.$ctor1(settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Random.Next$1(settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Width-2|0)+1|0,settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Random.Next$1(settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Height-2|0)+1|0),System.Nullable.hasValue(result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$GetTile(pos.$clone()))){i=i-1|0;continue}found=!1;$t=Bridge.getEnumerator(settings.MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Directions);try{while($t.moveNext()){var dir=$t.Current.$clone(),loc1=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),dir.$clone()),loc2=MazeGenerators.Utils.Vector2.op_Subtraction(pos.$clone(),dir.$clone());result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$IsInRegion(loc1.$clone())&&result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$IsInRegion(loc2.$clone())&&(region1=result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$GetTile(loc1.$clone()),region2=result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$GetTile(loc2.$clone()),region1!=null&&region2!=null&&(found=!0))}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}if(!found){i=i-1|0;continue}result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$SetTile(pos.$clone(),connectorId);result.MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$Junctions.add(pos.$clone())}}}}});Bridge.define("MazeGenerators.Utils.RegionConnector.TreeMazeBuilderAlgorythm",{statics:{methods:{GrowMaze:function(result,settings,start,regionId){var $t,cells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor),lastDir,cell,unmadeCells,dir,dir1;for(result.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$SetTile(start.$clone(),regionId),cells.add(start.$clone()),lastDir=null;cells.Count>0;){cell=cells.getItem(cells.Count-1|0).$clone();unmadeCells=new(System.Collections.Generic.List$1(MazeGenerators.Utils.Vector2).ctor);$t=Bridge.getEnumerator(settings.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Directions);try{while($t.moveNext())dir=$t.Current.$clone(),MazeGenerators.Utils.RegionConnector.TreeMazeBuilderAlgorythm.CanCarve(result,cell.$clone(),dir.$clone())&&unmadeCells.add(dir.$clone())}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}unmadeCells.Count!==0?(dir1=new MazeGenerators.Utils.Vector2,dir1=lastDir!=null&&unmadeCells.contains(System.Nullable.getValue(lastDir).$clone())&&settings.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Random.Next$1(100)>settings.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$WindingPercent?System.Nullable.getValue(lastDir).$clone():unmadeCells.getItem(settings.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Random.Next$1(unmadeCells.Count)).$clone(),result.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),dir1.$clone()),regionId),result.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$SetTile(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2)),regionId),cells.add(MazeGenerators.Utils.Vector2.op_Addition(cell.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(dir1.$clone(),2))),lastDir=dir1.$clone()):(cells.removeAt(cells.Count-1|0),lastDir=null)}},CanCarve:function(result,pos,direction){var block=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),3)),end;return result.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$IsInRegion(block.$clone())?(end=MazeGenerators.Utils.Vector2.op_Addition(pos.$clone(),MazeGenerators.Utils.Vector2.op_Multiply(direction.$clone(),2)),!System.Nullable.hasValue(result.MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$GetTile(end.$clone()))):!1}}}});Bridge.define("MazeGenerators.Utils.Vector2",{$kind:"struct",statics:{methods:{op_Addition:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(a.X+b.X|0,a.Y+b.Y|0)},op_Subtraction:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(a.X-b.X|0,a.Y-b.Y|0)},op_Multiply:function(a,b){return new MazeGenerators.Utils.Vector2.$ctor1(Bridge.Int.mul(a.X,b),Bridge.Int.mul(a.Y,b))},getDefaultValue:function(){return new MazeGenerators.Utils.Vector2}}},fields:{X:0,Y:0},ctors:{$ctor1:function(x,y){this.$initialize();this.X=x;this.Y=y},ctor:function(){this.$initialize()}},methods:{LengthSquared:function(){return Bridge.Int.mul(this.X,this.X)+Bridge.Int.mul(this.Y,this.Y)|0},getHashCode:function(){return Bridge.addHash([1955977157,this.X,this.Y])},equals:function(o){return Bridge.is(o,MazeGenerators.Utils.Vector2)?Bridge.equals(this.X,o.X)&&Bridge.equals(this.Y,o.Y):!1},$clone:function(to){var s=to||new MazeGenerators.Utils.Vector2;return s.X=this.X,s.Y=this.Y,s}}});Bridge.define("MazeGenerators.RoomMazeGenerator.Result",{inherits:[MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverResult,MazeGenerators.Utils.RegionConnector.IRegionConnectorResult,MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderResult],$kind:"nested class",fields:{Regions:null,Rooms:null},props:{Junctions:null},alias:["Junctions","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$Junctions","GetTile","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$GetTile","GetTile","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$GetTile","GetTile","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$GetTile","SetTile","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$SetTile","SetTile","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$SetTile","RemoveTile","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$RemoveTile","IsInRegion","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$IsInRegion","IsInRegion","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$IsInRegion","IsInRegion","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$IsInRegion"],methods:{GetTile:function(pos){return this.Regions.get([pos.X,pos.Y])},SetTile:function(pos,regionId){this.Regions.set([pos.X,pos.Y],regionId)},RemoveTile:function(pos){this.Regions.set([pos.X,pos.Y],null)},IsInRegion:function(loc){return loc.X>=0&&loc.Y>=0&&loc.X<System.Array.getLength(this.Regions,0)&&loc.Y<System.Array.getLength(this.Regions,1)}}});Bridge.define("MazeGenerators.RoomMazeGenerator.Settings",{inherits:[MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverSettings,MazeGenerators.Utils.RegionConnector.IRegionConnectorSettings,MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderSettings],$kind:"nested class",fields:{NumRoomTries:0,PreventOverlappedRooms:!1,RoomSize:0},props:{Width:0,Height:0,Random:null,Directions:null,WindingPercent:0,AdditionalPassages:0,RemoveDeadEnds:!1},alias:["Width","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Width","Width","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Width","Height","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Height","Height","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Height","Random","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Random","Random","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Random","Directions","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Directions","Directions","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Directions","Directions","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Directions","WindingPercent","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$WindingPercent","AdditionalPassages","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$AdditionalPassages","RemoveDeadEnds","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$RemoveDeadEnds","RemoveDeadEnds","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$RemoveDeadEnds"],ctors:{init:function(){this.NumRoomTries=100;this.PreventOverlappedRooms=!0;this.RoomSize=2;this.Width=21;this.Height=21;this.Random=new System.Random.ctor;this.Directions=MazeGenerators.Utils.Directions.CardinalDirs;this.WindingPercent=0;this.AdditionalPassages=10;this.RemoveDeadEnds=!0}}});Bridge.define("MazeGenerators.TreeMazeGenerator.Result",{inherits:[MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverResult,MazeGenerators.Utils.RegionConnector.IRegionConnectorResult,MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderResult],$kind:"nested class",fields:{Regions:null},props:{Junctions:null},alias:["Junctions","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$Junctions","GetTile","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$GetTile","GetTile","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$GetTile","GetTile","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$GetTile","SetTile","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$SetTile","SetTile","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$SetTile","RemoveTile","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$RemoveTile","IsInRegion","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderResult$IsInRegion","IsInRegion","MazeGenerators$Utils$RegionConnector$IRegionConnectorResult$IsInRegion","IsInRegion","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverResult$IsInRegion"],methods:{GetTile:function(pos){return this.Regions.get([pos.X,pos.Y])},SetTile:function(pos,regionId){this.Regions.set([pos.X,pos.Y],regionId)},RemoveTile:function(pos){this.Regions.set([pos.X,pos.Y],null)},IsInRegion:function(loc){return loc.X>=0&&loc.Y>=0&&loc.X<System.Array.getLength(this.Regions,0)&&loc.Y<System.Array.getLength(this.Regions,1)}}});Bridge.define("MazeGenerators.TreeMazeGenerator.Settings",{inherits:[MazeGenerators.Utils.DeadendRemover.IDeadEndRemoverSettings,MazeGenerators.Utils.RegionConnector.IRegionConnectorSettings,MazeGenerators.Utils.RegionConnector.ITreeMazeBuilderSettings],$kind:"nested class",props:{Width:0,Height:0,Random:null,Directions:null,WindingPercent:0,AdditionalPassages:0,RemoveDeadEnds:!1},alias:["Width","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Width","Width","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Width","Height","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Height","Height","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Height","Random","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Random","Random","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Random","Directions","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$Directions","Directions","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$Directions","Directions","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$Directions","WindingPercent","MazeGenerators$Utils$RegionConnector$ITreeMazeBuilderSettings$WindingPercent","AdditionalPassages","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$AdditionalPassages","RemoveDeadEnds","MazeGenerators$Utils$RegionConnector$IRegionConnectorSettings$RemoveDeadEnds","RemoveDeadEnds","MazeGenerators$Utils$DeadendRemover$IDeadEndRemoverSettings$RemoveDeadEnds"],ctors:{init:function(){this.Width=21;this.Height=21;this.Random=new System.Random.ctor;this.Directions=MazeGenerators.Utils.Directions.CardinalDirs;this.WindingPercent=100;this.AdditionalPassages=20;this.RemoveDeadEnds=!0}}})});